# è½¯å·¥lab1ä»£ç æ›´è¿­å†…å®¹

# éœ€æ±‚åˆ†æ

å¼€å‘ä¸€ä¸ªç¨‹åºï¼Œå®ç°ä»æ–‡æœ¬æ–‡ä»¶ä¸­è¯»å–æ•°æ®å¹¶æ ¹æ®è¦æ±‚ç”Ÿæˆå›¾ç»“æ„ï¼Œè¾“å‡ºè¯¥å›¾ç»“æ„ï¼Œå¹¶åœ¨å…¶ä¸Šè¿›è¡Œä¸€ç³»åˆ—è®¡ç®—æ“ä½œï¼Œå®æ—¶å±•ç¤ºå„æ“ä½œçš„ç»“æœã€‚

å¼€å‘çš„ç¨‹åºå¯ä»¥æ˜¯å‘½ä»¤è¡Œæ–¹å¼è¿è¡Œï¼Œä¹Ÿå¯ä»¥ç”¨å›¾å½¢åŒ–ç”¨æˆ·ç•Œé¢GUIçš„æ–¹å¼è¿è¡Œã€‚æ— è®ºä½•ç§æ–¹å¼ï¼Œå‡åº”è¦†ç›–åç»­æ‰€æœ‰åŠŸèƒ½éœ€æ±‚ã€‚

![Untitled](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/5f322b49-4d00-4143-9de3-1b57405170d6)


## åŠŸèƒ½éœ€æ±‚

### 1-è¯»å…¥æ–‡æœ¬å¹¶ç”Ÿæˆæœ‰å‘å›¾

â–ª **ç¨‹åºé¦–å…ˆè®©ç”¨æˆ·é€‰æ‹©æˆ–è¾“å…¥æ–‡æœ¬æ–‡ä»¶çš„ä½ç½®å’Œæ–‡ä»¶åã€‚ä¹Ÿå¯ä»¥å‚æ•°çš„å½¢å¼ï¼Œåœ¨å¯åŠ¨ç¨‹åºæ—¶æä¾›æ–‡ä»¶è·¯å¾„å’Œæ–‡ä»¶åã€‚**

â–ª **ç¨‹åºè¯»å…¥æ–‡æœ¬æ•°æ®ï¼Œè¿›è¡Œåˆ†æï¼Œå°†å…¶è½¬åŒ–ä¸ºæœ‰å‘å›¾ï¼š**

â€“ æœ‰å‘å›¾çš„èŠ‚ç‚¹ä¸ºæ–‡æœ¬ä¸­åŒ…å«çš„æŸä¸ªå•è¯ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰

â€“ ä¸¤ä¸ªèŠ‚ç‚¹A,Bä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹Aâ†’Bï¼Œæ„å‘³ç€åœ¨æ–‡æœ¬ä¸­è‡³å°‘æœ‰ä¸€å¤„ä½ç½®Aå’ŒBç›¸é‚»å‡ºç°ï¼ˆå³Aå’ŒBä¹‹é—´æœ‰ä¸”ä»…æœ‰1æˆ–å¤šä¸ªç©ºæ ¼ï¼‰ã€‚

â€“ Aâ†’Bçš„æƒé‡w=æ–‡æœ¬ä¸­Aå’ŒBç›¸é‚»å‡ºç°çš„æ¬¡æ•°ï¼Œw>=1ã€‚

### 2-å±•ç¤ºæœ‰å‘å›¾ï¼ˆvoid showDirectedGraph(type G, â€¦)ï¼‰

â–ª **å±•ç¤ºç”Ÿæˆçš„æœ‰å‘å›¾ã€‚**

â–ª **å¯é€‰åŠŸèƒ½ï¼šå°†ç”Ÿæˆçš„æœ‰å‘å›¾ä»¥å›¾å½¢æ–‡ä»¶å½¢å¼ä¿å­˜åˆ°ç£ç›˜ï¼Œå¯ä»¥è°ƒç”¨å¤–éƒ¨ç»˜å›¾åº“æˆ–ç»˜å›¾å·¥å…·APIè‡ªåŠ¨ç”Ÿæˆæœ‰å‘å›¾ï¼Œä½†ä¸èƒ½é‡‡ç”¨æ‰‹å·¥æ–¹å¼ç»˜å›¾ã€‚**

### 3-æŸ¥æ‰¾æ¡¥æ¥è¯ï¼ˆString queryBridgeWords(String word1, String word2)ï¼‰

â–ª **åœ¨ç”Ÿæˆæœ‰å‘å›¾ä¹‹åï¼Œç”¨æˆ·è¾“å…¥ä»»æ„ä¸¤ä¸ªè‹±æ–‡å•è¯word1ã€word2ï¼Œç¨‹åºä»å›¾ä¸­æŸ¥è¯¢å®ƒä»¬çš„â€œæ¡¥æ¥è¯â€ã€‚**

â–ª **word1ã€word2çš„æ¡¥æ¥è¯word3ï¼šå›¾ä¸­å­˜åœ¨ä¸¤æ¡è¾¹word1â†’word3,word3â†’word2ã€‚**

â–ª **è¾“å…¥çš„word1æˆ–word2å¦‚æœä¸åœ¨å›¾ä¸­å‡ºç°ï¼Œåˆ™è¾“å‡ºâ€œNo word1 or word2 in the graph!â€**

â–ª **å¦‚æœä¸å­˜åœ¨æ¡¥æ¥è¯ï¼Œåˆ™è¾“å‡ºâ€œNo bridge words from word1 to word2!â€**

â–ª **å¦‚æœå­˜åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªæ¡¥æ¥è¯ï¼Œåˆ™è¾“å‡ºâ€œThe bridge words from word1 to word2 are: xxx, xxx, and xxx.â€**

### 4-æ ¹æ®æ¡¥æ¥è¯ç”Ÿæˆæ–°æ–‡æœ¬ï¼ˆgenerateNewText(String inputText)ï¼‰

â–ª **ç”¨æˆ·è¾“å…¥ä¸€è¡Œæ–°æ–‡æœ¬ï¼Œç¨‹åºæ ¹æ®ä¹‹å‰è¾“å…¥æ–‡ä»¶ç”Ÿæˆçš„å›¾ï¼Œè®¡ç®—è¯¥æ–°æ–‡æœ¬ä¸­ä¸¤ä¸¤ç›¸é‚»çš„å•è¯çš„bridge wordï¼Œå°†bridge wordæ’å…¥æ–°æ–‡æœ¬çš„ä¸¤ä¸ªå•è¯ä¹‹é—´ï¼Œè¾“å‡ºåˆ°å±å¹•ä¸Šå±•ç¤ºã€‚**

â€“ å¦‚æœä¸¤ä¸ªå•è¯æ— bridge wordï¼Œåˆ™ä¿æŒä¸å˜ï¼Œä¸æ’å…¥ä»»ä½•å•è¯ï¼›

â€“ å¦‚æœä¸¤ä¸ªå•è¯ä¹‹é—´å­˜åœ¨å¤šä¸ªbridge wordsï¼Œåˆ™éšæœºä»ä¸­é€‰æ‹©ä¸€ä¸ªæ’å…¥è¿›å»å½¢æˆæ–°æ–‡æœ¬ã€‚

â–ª **ä¾‹å¦‚ç”¨æˆ·è¾“å…¥ï¼šSeek to explore new and exciting synergies**

â–ª **åˆ™è¾“å‡ºç»“æœä¸ºï¼šSeek to explore strange new life and exciting synergies**

### 5-è®¡ç®—ä¸¤ä¸ªå•è¯ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆcalcShortestPath(String word1, String word2)ï¼‰

â–ª **ç”¨æˆ·è¾“å…¥ä¸¤ä¸ªå•è¯ï¼Œç¨‹åºè®¡ç®—å®ƒä»¬ä¹‹é—´åœ¨å›¾ä¸­çš„æœ€çŸ­è·¯å¾„ï¼ˆè·¯å¾„ä¸Šæ‰€æœ‰è¾¹æƒå€¼ä¹‹å’Œæœ€å°ï¼‰ï¼Œä»¥æŸ**

**ç§çªå‡ºçš„æ–¹å¼å°†è·¯å¾„æ ‡æ³¨åœ¨åŸå›¾å¹¶å±•ç¤ºåœ¨å±å¹•ä¸Šï¼ŒåŒæ—¶å±•ç¤ºè·¯å¾„çš„é•¿åº¦ï¼ˆæ‰€æœ‰è¾¹æƒå€¼ä¹‹å’Œï¼‰ã€‚**

â€“ ä¾‹å¦‚ï¼šè¾“å…¥toå’Œandï¼Œåˆ™å…¶æœ€çŸ­è·¯å¾„ä¸ºtoâ†’exploreâ†’strangeâ†’newâ†’lifeâ†’and

â–ª **å¦‚æœæœ‰å¤šæ¡æœ€çŸ­è·¯å¾„ï¼Œåªéœ€è¦å±•ç¤ºä¸€æ¡å³å¯ã€‚**

â€“ å¯é€‰ï¼šè®¡ç®—å‡ºæ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ï¼Œå¹¶ä»¥ä¸åŒçš„çªå‡ºæ˜¾ç¤ºæ–¹å¼å±•ç¤ºå‡ºæ¥ã€‚

â€“ ä¾‹å¦‚toå’Œandä¹‹é—´è¿˜æœ‰å¦ä¸€æ¡è·¯å¾„ï¼štoâ†’seekâ†’outâ†’newâ†’lifeâ†’andã€‚

â–ª **å¦‚æœè¾“å…¥çš„ä¸¤ä¸ªå•è¯â€œä¸å¯è¾¾â€ï¼Œåˆ™æç¤ºã€‚**

â–ª **å¯é€‰åŠŸèƒ½ï¼šå¦‚æœç”¨æˆ·åªè¾“å…¥ä¸€ä¸ªå•è¯ï¼Œåˆ™ç¨‹åºè®¡ç®—å‡ºè¯¥å•è¯åˆ°å›¾ä¸­å…¶ä»–ä»»ä¸€å•è¯çš„æœ€çŸ­è·¯å¾„ï¼Œå¹¶**

**é€é¡¹å±•ç¤ºå‡ºæ¥ã€‚**

### 6-éšæœºæ¸¸èµ°ï¼ˆrandomWalk()ï¼‰

â–ª **è¿›å…¥è¯¥åŠŸèƒ½æ—¶ï¼Œç¨‹åºéšæœºçš„ä»å›¾ä¸­é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥æ­¤ä¸ºèµ·ç‚¹æ²¿å‡ºè¾¹è¿›è¡Œéšæœºéå†ï¼Œè®°å½•ç»è¿‡çš„æ‰€æœ‰èŠ‚ç‚¹å’Œè¾¹ï¼Œç›´åˆ°å‡ºç°ç¬¬ä¸€æ¡é‡å¤çš„è¾¹ä¸ºæ­¢ï¼Œæˆ–è€…è¿›å…¥çš„æŸä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨å‡ºè¾¹ä¸ºæ­¢ã€‚**

**åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œç”¨æˆ·ä¹Ÿå¯éšæ—¶åœæ­¢éå†ã€‚**

â–ª **å°†éå†çš„èŠ‚ç‚¹è¾“å‡ºä¸ºæ–‡æœ¬ï¼Œå¹¶ä»¥æ–‡ä»¶å½¢å¼å†™å…¥ç£ç›˜ã€‚**

â–ª **ä¾‹å¦‚ï¼š**

â€“ to seek out new life and new worlds to explore strange new civilizations

â€“ to explore strange new worlds to explore

# æ·»åŠ å°†è¯»å…¥çš„è¯å˜æˆå°å†™çš„æƒ…å†µï¼ˆ2024-5-15ï¼‰

## ä¿®æ”¹å‰

![Untitled 1](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/38839348-4ecc-403f-8b43-ea8237a3972e)


![Untitled 2](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/9523a6e8-67ff-46b2-a2b2-4ff98d04adac)


## ä¿®æ”¹å

åœ¨å¤„ç†æ¯è¡Œæ•°æ®çš„æ—¶å€™åŠ å…¥ä¸€æ­¥å…¨éƒ¨è½¬æ¢ä¸ºå°å†™

```python
def showDirectedGraph(filename):
    global last_one
    try:
        with open(filename, 'r') as file:
            for line in file:
                words = re.findall(r'\b[A-Za-z]\w*\b', line)
                # å°†æ‰€æœ‰å•è¯è½¬æ¢ä¸ºå°å†™
                words = [word.lower() for word in words]
                for word in words:
                    add_node_if_not_exists(word)
                    if last_one:        
                        add_edge_with_weight(last_one, word)
                    last_one = word
    except FileNotFoundError:
        print("File not found!")
```

![Untitled 3](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/6f525200-a660-4616-a52a-0c784327ac84)


# åŒå‘è¾¹å‡ºé”™æƒ…å†µ

## ä¿®æ”¹å‰

`input.txt` å†…å®¹å¦‚ä¸‹ï¼š

> To explore strange new worlds,
To seek out new life and new civilizations and life and
> 

å›¾åƒå¦‚ä¸‹ï¼š

![Untitled 4](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/d6b1b2c5-6b48-4ec3-bd98-175be88dfede)


æŸ¥æ‰¾è¾¹æƒå€¼æ²¡æœ‰é—®é¢˜ï¼š

![Untitled 5](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/3c88640c-388e-45d6-b392-921d15fde77e)


å¯èƒ½æ˜¯å¦‚åŒå†…ç¯ä¸€æ ·ï¼Œ**æ ‡ç­¾è¢«è¦†ç›–äº†**

é¦–å…ˆå¯¹å›¾çš„ç±»åˆ«è¿›è¡Œäº†ä¿®æ”¹ï¼š

[å¤šé‡å›¾---æœ‰è‡ªå¾ªç¯å’Œå¹³è¡Œè¾¹çš„æ— å‘å›¾ â€” NetworkX 2.8 æ–‡æ¡£](https://www.osgeo.cn/networkx/reference/classes/multigraph.html)

```python
directed_graph = nx.MultiDiGraph()
```

ä½†æ˜¯ä½œå›¾ä»ç„¶æœ‰é—®é¢˜ï¼Œçœ‹å®˜ç½‘ç»™çš„æç¤ºæ˜¯ç”¨å…¶ä»–çš„åº“å¯¹å›¾åƒè¿›è¡Œç»˜åˆ¶ï¼š

[ç»˜å›¾ â€” NetworkX 2.8 æ–‡æ¡£](https://www.osgeo.cn/networkx/reference/drawing.html)

![Untitled 6](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/ed8786b3-841e-4f6b-96d4-62b6e53cb2e6)


å¯å–œçš„æ˜¯ä½¿ç”¨Graphvizåæˆ‘ä»¬å¾—åˆ°äº†åˆæ­¥æƒ³è¦çš„ç»“æœï¼š

![Untitled 7](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/50f75830-45eb-494c-9597-27e31fb41959)


æ¥ä¸‹æ¥å¡«ä¸Šè¾¹æƒå€¼å°±è¡Œ

<aside>
âœ¨ å…³äºæŠ¥warningé—®é¢˜çœ‹ä¸‹é¢çš„é“¾æ¥ï¼Œè¿™ä¸ªå‡½æ•°ç¡®å®æœ‰æ½œåœ¨çš„é—®é¢˜ï¼ˆè½¬æ¢çš„æ—¶å€™è¾¹æƒå€¼è½¬ä¸è¿‡å»ï¼‰

</aside>

## ä¿®æ”¹å

![Untitled 8](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/0625ef41-3e6a-4b43-8957-662f7c779e16)


---

```python
def visualize_graph():
    PG = nx.nx_pydot.to_pydot(directed_graph)
    # å°†åŸå›¾ä¸­çš„è¾¹æƒå€¼åŠ å…¥PGä¸­ï¼ŒPGæ˜¯Graphvizçš„å›¾å¯¹è±¡
    for edge in PG.get_edges():
        edge_label = str(directed_graph[edge.get_source()][edge.get_destination()]['weight'])
        edge.set_label(edge_label)
        
    PG.write_png('graph.png')
```

æ­£å¸¸ç»“æœå¦‚ä¸Šï¼Œä¸€äº›å¸¦è‡ªç¯å’Œå¹³è¡Œè¾¹æƒ…å†µå¦‚ä¸‹ï¼š

![Untitled 9](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/eabfdea6-3dee-4bac-b521-81e6d35122d3)


# æ¡¥æ¥è¯å¯»æ‰¾ï¼ˆ2024-5-16ï¼‰

## ä¿®æ”¹å‰

é‡‡ç”¨dfsç®—æ³•è¿›è¡Œæœæ ‘

## ä¿®æ”¹å

```python
def queryBridgeWords(word1, word2):
    # åˆ¤æ–­word1å’Œword2æ˜¯å¦åœ¨å›¾ä¸­
    if not directed_graph.has_node(word1) and not directed_graph.has_node(word2):
        return f"No \"{word1}\" and \"{word2}\" in the graph!"
    elif not directed_graph.has_node(word1):
        return f"No \"{word1}\" in the graph!"
    elif not directed_graph.has_node(word2):
        return f"No \"{word2}\" in the graph!"
    # ç”¨word3è®°å½•word1å’Œword2çš„æ¡¥æ¥è¯
    word3 = set()
    # éå†word1çš„é‚»å±…ï¼Œå†éå†word1çš„é‚»å±…çš„é‚»å±…ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰word2çš„é‚»å±…
    for neighbor in directed_graph.neighbors(word1):
        for neighbor2 in directed_graph.neighbors(neighbor):
            if neighbor2 == word2:
                word3.add(neighbor)
    if not word3:
        return f"No bridge words from \"{word1}\" to \"{word2}\"!"
    else:
        return f"The bridge words from \"{word1}\" to \"{word2}\" are: {', '.join(word3)}"
```

åœ¨å®éªŒæŒ‡å¯¼ä¹¦ä¸Šçš„æ¡ˆä¾‹å®Œå…¨ç¬¦åˆï¼ˆæŒ‡å¯¼ä¹¦ç”šè‡³æ‰“é”™ç³»åŠ¨è¯å½¢å¼äº†ï¼‰ï¼Œå¯¹äºè‡ªç¯å’Œå¹³è¡Œè¾¹æƒ…å†µä¹Ÿå¯å¤„ç†ã€‚

# æ’å…¥æ–‡æœ¬é—®é¢˜

## ä¿®æ”¹å‰

```python
def generateNewText(input_text):
    new_text = []
    words = input_text.lower().split()
    for i in range(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]
        new_text.append(word1)

        if directed_graph.has_node(word1) and directed_graph.has_node(word2):
            bridge_word = queryBridgeWords(word1, word2) #æŸ¥è¯¢æ˜¯å¦æœ‰æ¡¥æ¥è¯
            if bridge_word:
                new_text.append(bridge_word)

    new_text.append(words[-1])

    return ' '.join(new_text)
```

## ä¿®æ”¹å

```python
def generateNewText(input_text):
    new_text = []
    words = input_text.lower().split()
    # print(words)
    for i in range(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]
        new_text.append(word1)
        if directed_graph.has_node(word1) and directed_graph.has_node(word2):
            bridge_word = queryBridgeWords(word1, word2, False) #æŸ¥è¯¢æ˜¯å¦æœ‰æ¡¥æ¥è¯
            if bridge_word: 
                random_num = random.randint(0, len(bridge_word)-1)
                new_text.append(bridge_word[random_num])
    new_text.append(words[-1])
    return ' '.join(new_text)
```

ä¸»è¦æ·»åŠ äº†éšæœºé€‰å–æ“ä½œ

åŒæ—¶å¯¹æ¡¥æ¥è¯éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ï¼š

```python
def queryBridgeWords(word1, word2, flag=True): # Falseè¡¨ç¤ºåªè¿”å›æ¡¥æ¥è¯ä¸è¾“å‡ºæç¤ºè¯­å¥
    word3 = []
    # åˆ¤æ–­word1å’Œword2æ˜¯å¦åœ¨å›¾ä¸­
    if flag:
        if not directed_graph.has_node(word1) and not directed_graph.has_node(word2):
            print(f"No \"{word1}\" and \"{word2}\" in the graph!")
        elif not directed_graph.has_node(word1):
            print(f"No \"{word1}\" in the graph!")
        elif not directed_graph.has_node(word2):
            print(f"No \"{word2}\" in the graph!")
    if not directed_graph.has_node(word1) or not directed_graph.has_node(word2):
        return word3
    # ç”¨word3è®°å½•word1å’Œword2çš„æ¡¥æ¥è¯
    # éå†word1çš„é‚»å±…ï¼Œå†éå†word1çš„é‚»å±…çš„é‚»å±…ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰word2çš„é‚»å±…
    for neighbor in directed_graph.neighbors(word1):
        for neighbor2 in directed_graph.neighbors(neighbor):
            if neighbor2 == word2:
                word3.append(neighbor)
    if flag:
        if not word3:
            print(f"No bridge words from \"{word1}\" to \"{word2}\"!")
        else:
            print(f"The bridge words from \"{word1}\" to \"{word2}\" are: {', '.join(word3)}")
    return word3
```

ä¸»å‡½æ•°ä¸­ä¸å†è¾“å‡ºresultï¼Œ2æ—¶ä¸éœ€è¦è¾“å…¥ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œ3æ—¶ç¬¬ä¸‰ä¸ªå‚æ•°è®¾ä¸ºFalse

# æœ€çŸ­è·¯å¾„å¯»æ‰¾ï¼ˆ2024-5-17ï¼‰

## ä¿®æ”¹å‰

```python
def calcShortestPath(word1, word2):
    if not directed_graph.has_node(word1) or not directed_graph.has_node(word2):
        return "Word1 or Word2 not in the graph!"

    distances = {node: float('inf') for node in directed_graph}
    distances[word1] = 0
    previous_nodes = {}
    min_heap = [(0, word1)]

    while min_heap:
        current_distance, current_node = heapq.heappop(min_heap)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in directed_graph[current_node].items():
            distance = current_distance + weight['weight']

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_nodes[neighbor] = current_node
                heapq.heappush(min_heap, (distance, neighbor))

    path = []
    current = word2
    while current in previous_nodes:
        path.insert(0, current)
        current = previous_nodes[current]
    path.insert(0, word1)

    return f"Shortest path: {' -> '.join(path)}, Length: {distances[word2]}"
```

ä½¿ç”¨äº†æ¯”è¾ƒé«˜çº§çš„å †ç®—æ³•+Dijkstraç®—æ³•ï¼Œæ²¡çœ‹æ‡‚â€¦..é€‰æ‹©æ”¹æˆæ™®é€šçš„Dijkstraç®—æ³•

## ä¿®æ”¹å

```python
def calcShortestPath(word1, word2): # è®¡ç®—word1åˆ°word2çš„æœ€çŸ­è·¯å¾„
    if not directed_graph.has_node(word1) or not directed_graph.has_node(word2):
        return "Word1 or Word2 not in the graph!"

    # Dijkstraç®—æ³•å¯»æ‰¾ä»word1åˆ°word2çš„æœ€çŸ­è·¯å¾„
    distances = {node: float('inf') for node in directed_graph}
    distances[word1] = 0
    previous_nodes = {node: word1 for node in directed_graph}
    flag = {node: False for node in directed_graph}  # æ ‡è®°æ˜¯å¦å·²ç»åŠ å…¥é¡¶ç‚¹é›†
    # åˆå§‹åŒ–distanceçŸ©é˜µ
    for neighbor, weight in directed_graph[word1].items():
        distances[neighbor] = weight['weight']
        previous_nodes[neighbor] = word1
    distances[word1] = 0
    flag[word1] = True
    # å¯»æ‰¾distanceçŸ©é˜µä¸­æœ€å°å€¼
    for j in range(len(directed_graph)-1): 
        min = float('inf')
        current_node = None
        for i in distances:
            if flag[i]:
                continue
            else:
                if distances[i] < min:
                    min = distances[i]
                    current_node = i
        flag[current_node] = True
        # æ›´æ–°distanceçŸ©é˜µå’Œprevious_nodesçŸ©é˜µ
        for i in distances:
            if flag[i]:
                continue
            else:
                if directed_graph.has_edge(current_node, i):
                    distance = min + directed_graph[current_node][i]['weight']
                    if distance < distances[i]:
                        distances[i] = distance
                        previous_nodes[i] = current_node
                else:
                    continue
    # print(distances)
    # print(previous_nodes)
    # å›æº¯è·¯å¾„
    path = []
    current = word2
    # while current in previous_nodes:
    while current != word1:
        path.insert(0, current)
        current = previous_nodes[current]
    path.insert(0, word1)
    return f"Shortest path: {' -> '.join(path)}, Length: {distances[word2]}"
```

## å…³äºå¯é€‰åŠŸèƒ½

### å¯é€‰åŠŸèƒ½1-æ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„ï¼ˆå·²å®Œæˆï¼‰ï¼ˆ2024-5-20ï¼‰

å¯é€‰åŠŸèƒ½è¦æ±‚è¾“å‡ºæ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„ï¼Œæœ€çŸ­è·¯å¾„ä¸åŒæºè‡ªäºåœ¨æŸæ¬¡å¯»æ‰¾`distance`æœ€å°å€¼çš„æ—¶å€™å¯èƒ½å‡ºç°å¤šä¸ªç›¸åŒçš„æœ€å°å€¼ï¼Œé»˜è®¤é€‰å–çš„æ˜¯æ ‡å·ä»å°åˆ°å¤§çš„ç¬¬ä¸€ä¸ªï¼Œå¯¼è‡´åç»­ç»“æœä¸åŒã€‚

<aside>
ğŸ‘‰ [1]ç‹å¿—åš,éŸ©ä¼Ÿä¸€,æä¸€å†›.å…·æœ‰å¤šæ¡æœ€çŸ­è·¯å¾„çš„æœ€çŸ­è·¯é—®é¢˜[J].å“ˆå°”æ»¨å·¥ä¸šå¤§å­¦å­¦æŠ¥,2010,42(09):1428-1431.
</aside>

æ ¹æ®è®ºæ–‡ä¸­çš„ä¼ªä»£ç å®ç°æœ€çŸ­è·¯å¾„å›¾ï¼Œåœ¨å›¾ä¸Šé€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢éå†ä»`word1` åˆ°`word2` çš„è·¯å¾„è¾“å‡ºï¼Œå¯¹äºæ¯ä¸ªè·¯å¾„éƒ½è¾“å‡ºä¸åŒçš„å›¾`minPath_word1_word2_n.png` 

ç»“æœå¦‚ä¸‹ï¼š

![Untitled 10](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/9e91471a-a637-4118-ba4b-43f2cc6c3fd0)


![Untitled 11](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/0db3a109-42ef-4ed8-a540-17f023d7a245)


There are 2 shortest paths from "to" to "and". Their lengths are: 5.

Choose an option:

1. Show Directed Graph
2. Query Bridge Words
3. Generate New Text
4. Calculate Shortest Path
5. Random Walk
6. Exit
Exiting program.

### å¯é€‰åŠŸèƒ½2-åœ¨å›¾ä¸Šè¿›è¡Œæ ‡æ³¨ï¼ˆå·²å®Œæˆï¼‰ï¼ˆ2024-5-17ï¼‰

é‡‡ç”¨é‡æ–°äº§ç”Ÿå›¾åƒ`minPath_word1_word2.png` çš„æ–¹å¼ï¼Œåœ¨UIä¸­å¯ä»¥å±•ç¤ºè¿™ä¸€ç”»é¢

![Untitled 12](https://github.com/Yuanciel/Lab1-2021110973/assets/151415789/425a8e57-0103-41ba-935b-9bfca2e483d3)


# (to be continued)å¯è¿›ä¸€æ­¥å†…å®¹

## å¥—å£³UI

å¯ä»¥ç”¨`PyQt5`è¿›è¡Œå¥—å£³ï¼Œä½†æ˜¯æˆ‘ä¸ªäººæ„Ÿè§‰æ²¡å¿…è¦ï¼Œä¹‹åå¯èƒ½è½¬æˆ˜javaï¼Œåœ¨Pythonä¸ŠèŠ±å¤ªå¤šåŠŸå¤«æ²¡æœ‰ä»€ä¹ˆç”¨

## æ”¹java

to be continued

# randomwalkå’Œå¦‚ä½•å…è®¸ç”¨æˆ·æ‰“æ–­éå†ï¼ˆ2024-5-18ï¼‰

## ä¿®æ”¹å‰

æ²¡æœ‰å…è®¸æ‰“æ–­æ“ä½œï¼Œä¸”æ²¡æœ‰ç»™ç”¨æˆ·æ‰“æ–­çš„æ—¶é—´æ•´ä¸ªéå†å°±ä¼šç»“æŸ

```python
def randomWalk(directed_graph):
if not directed_graph or len(directed_graph.nodes) == 0:
return "Graph is empty."
visited_nodes = []  # å­˜å‚¨å·²ç»è®¿é—®çš„èŠ‚ç‚¹
visited_edges = set()  # ä½¿ç”¨é›†åˆæ¥å­˜å‚¨å·²ç»è®¿é—®çš„è¾¹ï¼Œç¡®ä¿è¾¹ä¸é‡å¤
current_node = random.choice(list(directed_graph.nodes))

while True:
    visited_nodes.append(current_node)
    neighbors = list(directed_graph.neighbors(current_node))

    # è¿‡æ»¤æ‰å·²ç»è®¿é—®è¿‡çš„è¾¹
    unvisited_neighbors = [n for n in neighbors if (current_node, n) not in visited_edges]
    if not unvisited_neighbors:
        break

    next_node = random.choice(unvisited_neighbors)
    visited_edges.add((current_node, next_node))

    current_node = next_node

result = "Visited Nodes:\\n"
for node in visited_nodes:
    result += f"- {node}\\n"

with open("random_walk_output.txt", "w") as file:
    file.write(result)

return result

```

## ä¿®æ”¹å

åŠ å…¥çº¿ç¨‹ï¼Œæ£€æµ‹ç”¨æˆ·æ˜¯å¦è¾“å…¥enter

å¹¶å¼•å…¥time.sleep()å‡½æ•°ï¼Œå°†delayè®¾ç½®ä¸º1ï¼Œä¹Ÿå°±æ˜¯ä¸€ç§’é’Ÿå¾€ä¸‹æ¸¸èµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®©ç”¨æˆ·æœ‰è¶³å¤Ÿçš„æ—¶é—´éšæ—¶æ‰“æ–­ã€‚å¹¶ä¸”å¼•å…¥æ ‡å¿—ä½æ¥ç¡®ä¿å¦‚æœæ²¡æœ‰è¢«æ‰“æ–­ä¸ä¼šä¸€ç›´ç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼Œè€Œæ˜¯æ­£å¸¸ç»“æŸ

çº¿ç¨‹éƒ¨åˆ†ï¼šä¸€æ—¦ç”¨æˆ·æŒ‰ä¸‹ Enter é”®ï¼Œ**`stop_event.set()`** è¢«è°ƒç”¨ã€‚**`set()`** æ–¹æ³•å°† **`stop_event`** æ ‡è®°ä¸ºå·²è®¾ç½®ï¼Œè¿™å°†åœ¨ä¸»çº¿ç¨‹ä¸­è¢«æ£€æµ‹åˆ°ï¼Œå¹¶è§¦å‘åœæ­¢éšæœºæ¸¸èµ°å¹¶è¾“å‡ºç»“æœçš„æ“ä½œã€‚

```python
def check_user_input(stop_event):
    input("Press Enter to stop the random walk...")
    stop_event.set()

def randomWalk(delay=1):
    if not directed_graph or len(directed_graph.nodes) == 0:
        return "Graph is empty."

    visited_nodes = []  # å­˜å‚¨å·²ç»è®¿é—®çš„èŠ‚ç‚¹
    visited_edges = set()  # ä½¿ç”¨é›†åˆæ¥å­˜å‚¨å·²ç»è®¿é—®çš„è¾¹ï¼Œç¡®ä¿è¾¹ä¸é‡å¤
    current_node = random.choice(list(directed_graph.nodes))
    interrupted_by_user = False  # æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæ˜¯å¦è¢«ç”¨æˆ·æ‰“æ–­

    # äº‹ä»¶ç”¨äºæ ‡è®°æ˜¯å¦ç”¨æˆ·è¯·æ±‚åœæ­¢
    stop_event = threading.Event()
    input_thread = threading.Thread(target=check_user_input, args=(stop_event,))
    input_thread.start()

    try:
        while True:
            visited_nodes.append(current_node)
            neighbors = list(directed_graph.neighbors(current_node))

            # è¿‡æ»¤æ‰å·²ç»è®¿é—®è¿‡çš„è¾¹
            unvisited_neighbors = [n for n in neighbors if (current_node, n) not in visited_edges]
            if not unvisited_neighbors:
                break

            next_node = random.choice(unvisited_neighbors)
            visited_edges.add((current_node, next_node))

            current_node = next_node

            # åŠ å…¥å»¶è¿Ÿ
            time.sleep(delay)

            # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‰“æ–­æ¸¸èµ°
            if threading.main_thread().is_alive() and not interrupted_by_user:
                continue  # ç»§ç»­ä¸‹ä¸€æ¬¡è¿­ä»£
            else:
                break  # ç”¨æˆ·æ‰“æ–­æˆ–è€…éå†å®Œæ‰€æœ‰èŠ‚ç‚¹ï¼Œé€€å‡ºå¾ªç¯
    except KeyboardInterrupt:
        interrupted_by_user = True
    finally:
        if interrupted_by_user:
            visited_nodes.append("(Interrupted by user)")
        else:
            visited_nodes.append("(Finished without interruption)")

        result = "Visited Nodes:\n"
        for node in visited_nodes:
            result += f"- {node}\n"

        with open("random_walk_output.txt", "w") as file:
            file.write(result)

    return result
```

## ä¿®æ”¹å2.0

å‘ç°æœ‰çš„æ—¶å€™æŒ‰enteræ‰“æ–­ä¸äº†ï¼Œæ‰€ä»¥æ„Ÿè§‰æ˜¯åˆ¤æ–­æ˜¯å¦breakçš„æ¡ä»¶æœ‰é—®é¢˜æ”¹æˆäº†å¦‚ä¸‹åˆ¤æ–­ï¼š

```jsx
if stop_event.is_set():
    interrupted_by_user = True
    break  # ç”¨æˆ·æ‰“æ–­ï¼Œé€€å‡ºå¾ªç¯

```

åŸæ¥çš„é‚£ä¸ªæ„Ÿè§‰ä¼šå› ä¸ºæ²¡æœ‰å®æ—¶ç›‘æ§æ˜¯å¦è¢«æ‰“æ–­è€Œå‡ºä¸å»å¾ªç¯ï¼Œåªèƒ½ç­‰ä»–éå†å®Œè€Œä¸èƒ½æ‰“æ–­ï¼Œä½†æ˜¯ä¸çŸ¥é“ä¸ºä»€ä¹ˆç¬¬ä¸€å¤©å†™çš„æ—¶å€™è¿™é‡Œè¯¡å¼‚çš„æµ‹è¿‡å»äº†ã€

# ä¿®æ­£Dijkstraç®—æ³•

## ä¿®æ”¹å‰

ä»…è¾“å‡ºå…¶ä¸­ä¸€æ¡æœ€çŸ­è·¯å¾„

## ä¿®æ”¹å

è¾“å‡ºå›¾ä¸Šæ‰€æœ‰æœ€çŸ­è·¯å¾„ï¼Œå¦‚æœ`word1`åˆ°`word2`ä¸å¯è¾¾ï¼Œä¹Ÿè¾“å‡ºç›¸åº”ä¿¡æ¯ã€‚

[å¯é€‰åŠŸèƒ½1-æ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„ï¼ˆå·²å®Œæˆï¼‰ï¼ˆ2024-5-20ï¼‰](https://www.notion.so/1-2024-5-20-aa295954fda34d68a0c379c4cb4b85e6?pvs=21) 

# ç®€å•ä¿®æ”¹ä½¿ç”Ÿæˆçš„ä¸­é—´å›¾åƒè¾“å‡ºå‡ºæ¥

## ä¿®æ”¹å‰

å›¾åœ¨ç£ç›˜ä¸­å­˜å‚¨ï¼Œå¹¶ä¸å±•ç¤ºå‡ºæ¥

## ä¿®æ”¹å

é€šè¿‡`matplotlib` å°†ç£ç›˜ä¸­çš„å›¾æ˜¾ç¤ºå±•ç¤ºå‡ºæ¥
